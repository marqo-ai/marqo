import json
from typing import List, Dict, Set, Optional, Any, Generator, Tuple, Protocol, cast, Union

import numpy as np
from PIL.Image import Image
from pydantic.main import BaseModel

from marqo.core import constants
from marqo.core.constants import MARQO_DOC_ID
from marqo.core.exceptions import AddDocumentsError
from marqo.core.models.marqo_index import FieldType


class Chunker(Protocol):
    def __call__(self, field_content: str, single_chunk: bool = False) -> Tuple[List[str], List[str]]:
        ...


class Vectoriser(Protocol):
    def __call__(self, content_chunks: Union[List[str], List[Image]]) -> List[List[float]]:
        ...


class TensorFieldContent(BaseModel):
    field_content: str
    field_type: FieldType

    chunks: Optional[List[str]] = []  # TODO check other types
    content_chunks: Optional[Union[List[str], List[Image]]] = []  # TODO check other types
    embeddings: Optional[List[List[float]]] = []

    # metadata fields
    is_tensor_field: bool
    is_multimodal_subfield: bool = False
    tensor_field_chunk_count: int = 0

    class Config:
        arbitrary_types_allowed = True

    def populate_chunks_and_embeddings(self, chunks: List[str], embeddings: List[List[float]]) -> None:
        """
        This method is called in two scenarios
        - When we collect custom vector fields, we can directly populate chunks and embeddings
        - When we populate embeddings from existing docs
        """
        self.chunks = chunks
        self.embeddings = embeddings
        self.tensor_field_chunk_count = len(chunks)

    def chunk(self, chunkers: Dict[FieldType, Chunker]):
        if self.field_type not in chunkers:
            raise AddDocumentsError(f'Chunking is not supported for field type: {self.field_type.name}')

        chunker = chunkers[self.field_type]

        # chunk top-level fields
        if not self.chunks and (self.is_tensor_field or self._is_audio_or_video()):
            chunks, content_chunks = chunker(self.field_content, single_chunk=False)
            self.chunks.extend(chunks)
            self.content_chunks.extend(content_chunks)
            self.tensor_field_chunk_count = len(chunks)

        # chunk subfields of multimodal combo fields
        if self.is_multimodal_subfield and not self._is_audio_or_video():
            # We do not chunk subfields of a multimodal combo field, except for audio and video fields
            # If this field is also a top level tensor field, it might already have the chunk we need
            # So we check if the single chunk generated by chunker matches the last chunk of the tensor field
            # If not, we attach the single chunk to the exiting chunk for embedding.
            chunks, content_chunks = chunker(self.field_content, single_chunk=True)

            if not self.chunks or chunks[0] != self.chunks[-1]:
                self.chunks.extend(chunks)
                self.content_chunks.extend(content_chunks)

    def vectorise(self, vectorisers: Dict[FieldType, Vectoriser]) -> None:
        if self.field_type not in vectorisers:
            raise AddDocumentsError(f'Vectorisation is not supported for field type: {self.field_type.name}')

        if not self.content_chunks:
            return

        embeddings = vectorisers[self.field_type](self.content_chunks)
        self.embeddings.extend(embeddings)
        self.content_chunks = []  # drop it after vectorisation so memory can be freed

    @property
    def tensor_field_chunks(self):
        return self.chunks[:self.tensor_field_chunk_count]

    @property
    def tensor_field_embeddings(self):
        return self.embeddings[:self.tensor_field_chunk_count]

    @property
    def sub_field_chunk(self):
        if not self.chunks or not self.is_multimodal_subfield:
            return None
        elif self._is_audio_or_video():
            return self.field_content
        else:
            return self.chunks[-1]

    @property
    def sub_field_embedding(self):
        if not self.embeddings or not self.is_multimodal_subfield:
            return None
        elif self._is_audio_or_video():
            return np.mean(np.array(self.embeddings), axis=0).tolist()
        else:
            return self.embeddings[-1]

    def _is_audio_or_video(self):
        return self.field_type in [FieldType.AudioPointer, FieldType.VideoPointer]


class MultiModalTensorFieldContent(TensorFieldContent):
    weights: Dict[str, float]
    subfields: Dict[str, TensorFieldContent] = dict()
    normalize_embeddings: bool

    @property
    def tensor_field_chunks(self):
        if self.chunks:
            # populated from existing tensor
            return super().tensor_field_chunks

        if not self.subfields:
            return []

        subfield_chunks = {subfield: self.subfields[subfield].sub_field_chunk for subfield in self.weights.keys()
                           if subfield in self.subfields}
        return [json.dumps(subfield_chunks)]

    @property
    def tensor_field_embeddings(self):
        if self.embeddings:
            # populated from existing tensor
            return super().tensor_field_embeddings

        if not self.subfields:
            return []

        combo_embeddings = [
            np.array(self.subfields[subfield].sub_field_embedding) * weight for subfield, weight in self.weights.items()
            if subfield in self.subfields
        ]

        vector_chunk = np.squeeze(np.mean(combo_embeddings, axis=0))
        if self.normalize_embeddings:
            vector_chunk = vector_chunk / np.linalg.norm(vector_chunk)

        return [vector_chunk.tolist()]


class TensorFieldsContainer:

    def __init__(self, tensor_fields: List[str], custom_vector_fields: List[str], multimodal_combo_fields: dict):
        self._tensor_field_map: Dict[str, Dict[str, TensorFieldContent]] = dict()
        self._tensor_fields = set(tensor_fields)
        self._custom_tensor_fields: Set[str] = set(custom_vector_fields)
        self._multimodal_combo_fields = multimodal_combo_fields
        self._multimodal_sub_field_reverse_map: Dict[str, Set[str]] = dict()

        for field_name, weights in self._multimodal_combo_fields.items():
            for sub_field in weights.keys():
                if sub_field not in self._multimodal_sub_field_reverse_map:
                    self._multimodal_sub_field_reverse_map[sub_field] = set()
                self._multimodal_sub_field_reverse_map[sub_field].add(field_name)

    def is_custom_tensor_field(self, field_name: str) -> bool:
        return field_name in self._custom_tensor_fields

    def is_multimodal_field(self, field_name: str) -> bool:
        return field_name in self._multimodal_combo_fields

    def get_multimodal_field_mapping(self, field_name: str) -> Optional[dict]:
        return self._multimodal_combo_fields.get(field_name, None)

    def get_multimodal_sub_fields(self) -> Set[str]:
        return set(self._multimodal_sub_field_reverse_map.keys())

    def remove_doc(self, doc_id: str):
        if doc_id in self._tensor_field_map:
            del self._tensor_field_map[doc_id]

    def _add_tensor_field_content(self, doc_id: str, field_name: str, content: TensorFieldContent) -> None:
        if doc_id not in self._tensor_field_map:
            self._tensor_field_map[doc_id] = dict()
        self._tensor_field_map[doc_id][field_name] = content

    def tensor_fields_to_vectorise(self, *types: FieldType) -> Generator[str, str, TensorFieldContent]:
        for doc_id, fields in self._tensor_field_map.items():
            for field_name, tensor_field_content in fields.items():
                if doc_id not in self._tensor_field_map:
                    # removed during interation due to error handling
                    break

                if tensor_field_content.field_type not in types:
                    # type does not match
                    continue

                if tensor_field_content.embeddings is not None:
                    # already vectorised (from existing tensor), skip
                    continue

                if (field_name not in self._tensor_fields and
                        field_name in self._multimodal_sub_field_reverse_map and
                        all([fields[field].embeddings is not None
                             for field in self._multimodal_sub_field_reverse_map[field_name]
                             if field in fields])):
                    # if field is only used by multimodal fields and all multimodal fields using it are vectorised
                    continue

                yield doc_id, field_name, tensor_field_content

    def get_tensor_field_content(self, doc_id: str) -> Dict[str, TensorFieldContent]:
        return {field_name: content for field_name, content in self._tensor_field_map.get(doc_id, dict()).items()
                if content.is_tensor_field and content.tensor_field_chunks}

    def populate_tensor_from_existing_doc(self, existing_marqo_doc: Dict[str, Any],
                                          existing_multimodal_weights: Dict[str, Dict[str, float]]) -> None:
        doc_id = existing_marqo_doc[MARQO_DOC_ID]

        if doc_id not in self._tensor_field_map:
            return

        doc = self._tensor_field_map[doc_id]

        for field_name, tensor_content in doc.items():
            if not tensor_content.is_tensor_field:
                # If this is not top level tensor field, we do not populate from existing tensor
                # TODO confirm if this is expected for unstructured as well
                continue

            if tensor_content.embeddings:
                # Already populated, might be a custom vector
                continue

            if field_name in existing_multimodal_weights:
                # for multimodal_combo fields

                if tensor_content.field_type != FieldType.MultimodalCombination:
                    # Field with the same name is not a multimodal field in this batch
                    continue

                weights = cast(MultiModalTensorFieldContent, tensor_content).weights
                if existing_multimodal_weights[field_name] != weights:
                    # mapping config is different, need to re-vectorise
                    continue

                if any([sub_field not in existing_marqo_doc or sub_field not in doc or
                        existing_marqo_doc[sub_field] != doc[sub_field].field_content for sub_field in weights.keys()]):
                    # If content of any subfields does not match
                    continue

            else:
                # for other tensor fields

                if field_name not in existing_marqo_doc:
                    # This is a new field added to the doc, we need to vectorise it
                    continue

                if existing_marqo_doc[field_name] != tensor_content.field_content:
                    # Field content has changed, we need to re-vectorise
                    continue

            if (constants.MARQO_DOC_TENSORS not in existing_marqo_doc or
                    field_name not in existing_marqo_doc[constants.MARQO_DOC_TENSORS]):
                # This field is not a tensor field in existing doc, we need to vectorise
                continue

            existing_tensor = existing_marqo_doc[constants.MARQO_DOC_TENSORS][field_name]
            tensor_content.populate_chunks_and_embeddings(existing_tensor[constants.MARQO_DOC_CHUNKS],
                                                          existing_tensor[constants.MARQO_DOC_EMBEDDINGS])

    def collect(self, doc_id: str, field_name: str, field_content: Any, text_field_type: Optional[FieldType]) -> Any:
        if field_name not in self._tensor_fields and field_name not in self._multimodal_sub_field_reverse_map:
            # not tensor fields, no need to collect
            return field_content

        if self.is_custom_tensor_field(field_name):
            content = field_content['content']
            embedding = field_content['vector']
            tensor_field_content = TensorFieldContent(
                field_content=content,
                field_type=FieldType.CustomVector,
                is_tensor_field=True,
                is_multimodal_subfield=False,  # for now custom vectors can only be top level
            )
            tensor_field_content.populate_chunks_and_embeddings([content], [embedding])
            self._add_tensor_field_content(doc_id, field_name, tensor_field_content)
            return content

        if self.is_multimodal_field(field_name):
            raise AddDocumentsError(
                f"Field {field_name} is a multimodal combination field and cannot be assigned a value."
            )

        if not isinstance(field_content, str):
            raise AddDocumentsError(
                f'Invalid type {type(field_content)} for tensor field {field_name}'
            )

        self._add_tensor_field_content(
            doc_id, field_name, TensorFieldContent(
                field_content=field_content,
                field_type=text_field_type,
                is_tensor_field=field_name in self._tensor_fields,
                is_multimodal_subfield=field_name in self._multimodal_sub_field_reverse_map
            )
        )
        return field_content

    def collect_multi_modal_fields(self, doc_id: str, normalize_embeddings: bool):
        for field_name, weights in self._multimodal_combo_fields.items():
            self._add_tensor_field_content(doc_id, field_name, MultiModalTensorFieldContent(
                weights=weights,
                field_content='',
                field_type=FieldType.MultimodalCombination,
                subfields={subfield: self._tensor_field_map[doc_id][subfield] for subfield in weights.keys()
                           if doc_id in self._tensor_field_map and subfield in self._tensor_field_map[doc_id]},
                is_tensor_field=True,
                is_multimodal_subfield=False,
                normalize_embeddings=normalize_embeddings
            ))
            yield field_name, weights
